# 操作系统
## 一.内核（OS Kernel）特征
 * **并发**（不同于并行，并行必须为多核）：计算机系统中同时存在多个运行的程序，需要OS管理和调度
 * **共享**：“同时”访问，互斥共享
 * **虚拟**：利用多道程序设计技术，让每个用户（应用程序）都觉得有一个计算机专门为他服务
 * **异步**：程序的执行不是一贯到底，而是走走停停，向前推进的素的不可预知，但只要运行环境相同，OS需要保证程序<br/>运行的结果也要相同</br>
## 二.操作系统的启动
 * **DISK**：存放OS，bootloader也在DISK存储着
 * **BIOS**：基本I/O处理系统，开机检测各种各样的 I/O外设，BIOS系统程序本身就在内存里放着，不在DISK内
 * 所谓CPU控制权的交接，可以理解为CPU执行哪段代码，刚刚启动时，CPU执行BIOS程序代码，BIOS程序代码也可以控制CUP跳到内存的其它地址空间执行相应的程序，当    BIOS程序执行完毕开始执行加载进来的bootloader代码时，可以说BIOS将CPU的控制权交给了bootloader
 * 操作系统与设备和程序交互（操作系统 interface）：系统调用、异常、中断，面向外设是通过中断和IO来处理的，面向应用程序是通过系统调用和异常来处理
 * 用户态、内核态
## 三.计算机体系结构及内存分层
 * **虚拟内存**：内存指的是电脑的RAM，虚拟内存是将磁盘硬盘的内存虚拟化为内存，具体是将RAM里面暂时不用的数据程序存储到硬盘里，从而省出了内存的部分空间，可以看成虚拟化硬盘的一部分存储空间为内存
 * **地址空间**：物理地址和逻辑地址，逻辑地址是连续的，CPU依据逻辑地址去寻找相应的物理地址
 * **连续内存分配**：内存碎片问题、分区的动态分配包括第一适配、最佳适配、最差适配，压缩式碎片整理、交换式碎片整理
## 四.非连续内存分配
 * **分段**：段号+段内偏移量，段的大小不同，好处是可以实现隔离和共享  
 * **分页**：页号+偏移量，每页的大小相同。逻辑地址的页对应物理地址的帧，一般来说页的数目大于帧的数目，因为共享机制的存在
 * **页表**：页表就是一个大的数组
 * **TLB**：缓存近期访问的页帧转换表项，加快访问速度
 * **多级页表**：以时间换空间，分级次数越多，访问的次数也就越多，那些对应关系不在内存里的页表（flag里resident标志位为0的页表，也就是不合法页表）就占用内&emsp;　存的空间了
 * **反向页表**：以帧号为index，以页号为存储内容，这样的话页表的大小只与物理地址空间大小有关，而与逻辑地址空间大小无关，页表是小了，但查找费时间
 * **相应的方案有**：(1)基于页寄存器的方案，但无法索引，因为我们要的是根据页号获得帧号。(2)基于关联内存（类似HashMap）的方案，key放置页号，value放置帧号，缺点是造价高，太大时也无法放进CPU内存。(3)基于哈希（hash）查找的方案。
 ## 五.虚拟内存技术
 * 程序规模的增长远大于存储器容量的增长速度 ，让更多的程序运行在有限的内存内
 
 　　　　　　<img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/memorizer.PNG" width = 40% height = 35% />  
 * **覆盖技术**  
   * **目标**：在较小的可用内存中运行较大的程序，常用于多道程序系统，与区分存储管理配合使用
   * **原理**：把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行
   * **缺点**：(1)程序员要划分功能区，增加了编程的复杂度  
   &emsp;&emsp;&emsp;(2)覆盖模块从外出装入内存，实际上是以时间换空间
 * **交换技术**  
   * **目标**：多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源  
   * **方法**：可将暂时不能运行的程序送到外存，从而获得空闲内存空间
   * **缺点**：增加了处理器的开销
 * **覆盖与交换的比较**  
   * 覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间逻辑覆盖结构。
   * 交换技术是以在内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，交换发送在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部
 * **虚存技术**（Physical Memory + Disk = Virtual Memory） 
   * **目标**：(1)像覆盖技术那样，不是把程序的所有内容都放在内存中，但要做得更好，由操作系统自动来完成，无需程序员的干涉  
   &emsp;&emsp;&emsp;(2)像交换技术那样，能够实现进程在内存与外存之间的交换，但要做的更好，只对进程的部分内容在内存和外存之间进行交换
   * **程序的局部性原理**：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域，表现为时间局部性和空间局部性
   * **基本概念**  
     * 在装入程序时，不必将其全部装入到内存，而只需要将当前需要执行的部分页面或段装入到内存，就可以让程序开始执行
     * 在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或却段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序
     * 另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空间存放将要装入的程序以及将要调入的页面或段
## 六.虚拟内存技术（二）
* **最优页面置换算法**  
  * **功能**：当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换
  * **目标**：尽可能地减少页面的换进换出次数（即缺页中断的次数）。具体来说，把未来不会再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数来进行预测；
  * **基本思路**：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需要等待多长时间，丛总选择等待时间最长的那个，作为被置换的页面。但这只是一种理想情况，在实际系统中是无法实现的，因为操作系统无从知道每一个页面要等待多长时间以后才会再次被访问。可用作其他算法的性能评价的依据（在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法）。
  * **页面锁定（frame locking）**：用于描述必须常驻内存的操作系统的关键部分或时间键（time-critical）的应用进程。实现的方法是：在页表中添加锁定标志位（lock bit）
* **先进先出算法（FIFO）**
  * **基本思路**：选择在内存中驻留时间最长的页面并淘汰之。具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。当发生一个缺页中断时，吧链首页面淘汰出局，并把新的页面添加到链表的末尾。
  * **缺点**：性能较差，调出的页面有可能是经常要访问的页面，并且有Belady现象。FIFO算法很少单独使用。
* **最近最近未使用算法（Least Recently Used LRU）**
  * **基本思路**：当一个缺页中断发生时，选择最久未使用的那个页面，并淘汰之。它是对最优页面置换算法的一个近似，其依据是程序的局部性原理，即在最近一小段时间（最近几条指令）内，如果某些页面被频繁地访问，纳秒在将来的一小段时间内，它们还可能会再一次被频繁地访问。反过来说，如果在过去某些页面长时间未被访问，那么在将来它们还可能会长时间地得不到访问。
  * **缺点**：LRU算法需要记录各个页面使用时间的先后顺序，开销比较大
  * **实现方法**  
    * 系统维护一个页面链表，最近刚刚使用过的页面作为首结点，最久未使用的页面作为尾结点。每一次党文内存时，找到相应的页面，把它从链表中摘下来，在移动到链表之首。每次缺页中断发生时，淘汰链表末尾的页面。
    * 设置一个活动页面栈（不是通常意义上的栈，通常意义的栈只能在栈顶操作，不能直接操作栈的中间部分和栈底），当访问某页时，将此页号压入栈顶，然后，考察栈内是否有与此页面相同的页号，若有则抽出。当需要淘汰一个页面时，总是选择栈底的页面，它就是最久未使用的。
* **时钟页面置换算法**
  * Clock页面置换算法，LRU的近似，对FIFO的一种改进。
  * **基本思路**
    * 需要用到页表项当中的访问位，当一个页面被装入到内存时，把该位初始化为0,。然后如果这个页面被访问（读/写），则把该位置为1；
    * 把各个页面组织成环形链表（类似钟表明），把指针指向最老的页面（最先进来）；
    * 当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰；若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格
* **二次机会法**
  * Clock页面置换算法，LRU的近似，对FIFO的一种改进。
  * **基本思路**
    * 这里有一个巨大的代价来替换“脏”页（dirty page，也就是对该页做了写操作）。
    * 修改Clock算法，使它允许脏页总是在一次时钟头扫描中保留下来
    * 同时使用脏位和使用位来指导置换，被执行写操作次数越多的页，越不容易被替换出去
* **最不常用算法（Least Frequently Used,LFU）**  
  * **基本思路**：当一个缺页中断发生时，选择访问次数最少的那个页面，并淘汰之
  * **实现方法**：对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加 1.在发生缺页中断时，淘汰计数值最小的那个页面
  * **LRU和LFU的区别**：LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数或频度，访问次数越多越好。
   
   
   
   
   
   
   
   
   
   
