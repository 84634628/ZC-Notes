# 操作系统
## 一.内核（OS Kernel）特征
 * **并发**（不同于并行，并行必须为多核）：计算机系统中同时存在多个运行的程序，需要OS管理和调度
 * **共享**：“同时”访问，互斥共享
 * **虚拟**：利用多道程序设计技术，让每个用户（应用程序）都觉得有一个计算机专门为他服务
 * **异步**：程序的执行不是一贯到底，而是走走停停，向前推进的素的不可预知，但只要运行环境相同，OS需要保证程序<br/>运行的结果也要相同</br>
## 二.操作系统的启动
 * **DISK**：存放OS，bootloader也在DISK存储着
 * **BIOS**：基本I/O处理系统，开机检测各种各样的 I/O外设，BIOS系统程序本身就在内存里放着，不在DISK内
 * 所谓CPU控制权的交接，可以理解为CPU执行哪段代码，刚刚启动时，CPU执行BIOS程序代码，BIOS程序代码也可以控制CUP跳到内存的其它地址空间执行相应的程序，当    BIOS程序执行完毕开始执行加载进来的bootloader代码时，可以说BIOS将CPU的控制权交给了bootloader
 * 操作系统与设备和程序交互（操作系统 interface）：系统调用、异常、中断，面向外设是通过中断和IO来处理的，面向应用程序是通过系统调用和异常来处理
 * 用户态、内核态
## 三.计算机体系结构及内存分层
 * **逻辑地址**：是指由程序产生的与段相关的偏移地址部分，逻辑地址是连续的。
 * **逻辑地址空间**：逻辑地址空间是逻辑地址的范围，一个程序的逻辑地址空间大于等于其物理地址空间，那么有一个疑问，逻辑地址空间和物理地址空间都是在内存（RAM）上存储的，并且逻辑地址空间不小于物理地址空间，那么为何不将物理地址空间存储的内容直接放进逻辑地址空间，反而要多此一举的搞一个逻辑空间呢？答案肯定不是我们目前所设想的那样。我们注意到逻辑地址是连续的，按以前所设想的在内存上建立一个逻辑地址空间的话，那么其存储的内容会有大量的重复信息比如（页号，偏移量）：（0,0）（0,1）（0,2）（0,3）...,**既然逻辑地址是连续的那么我们只需知道首逻辑地址就行了，其它地址利用程序计数器依次加一就好了**，这样我们不需要建立整个逻辑地址存储空间，只需记录首逻辑地址即其它少量控制信息就行了。那么就剩下页表（逻辑地址页和物理地址帧的映射表）比较消耗内存了，如果页表所消耗内存比分配的物理内存还大，那么也就没必要做逻辑地址和物理地址的映射了，这种情况一般不会发生。
 * **虚拟内存**：内存指的是电脑的RAM，虚拟内存是将磁盘硬盘的内存虚拟化为内存，具体是将RAM里面暂时不用的数据程序存储到硬盘里，从而省出了内存的部分空间，可以看成虚拟化硬盘的一部分存储空间为内存
 * **地址空间**：物理地址和逻辑地址，逻辑地址是连续的，CPU依据逻辑地址去寻找相应的物理地址
 * **连续内存分配**：内存碎片问题、分区的动态分配包括第一适配、最佳适配、最差适配，压缩式碎片整理、交换式碎片整理
## 四.非连续内存分配
 * **分段**：段号+段内偏移量，段的大小不同，好处是可以实现隔离和共享  
 * **分页**：页号+偏移量，每页的大小相同。逻辑地址的页对应物理地址的帧，一般来说页的数目大于帧的数目，因为共享机制的存在
 * **页表**：页表就是一个大的数组
 * **TLB**：缓存近期访问的页帧转换表项，加快访问速度
 * **多级页表**：以时间换空间，分级次数越多，访问的次数也就越多，那些对应关系不在内存里的页表（flag里resident标志位为0的页表，也就是不合法页表）就占用内&emsp;　存的空间了
 * **反向页表**：以帧号为index，以页号为存储内容，这样的话页表的大小只与物理地址空间大小有关，而与逻辑地址空间大小无关，页表是小了，但查找费时间
 * **相应的方案有**：(1)基于页寄存器的方案，但无法索引，因为我们要的是根据页号获得帧号。(2)基于关联内存（类似HashMap）的方案，key放置页号，value放置帧号，缺点是造价高，太大时也无法放进CPU内存。(3)基于哈希（hash）查找的方案。
 ## 五.虚拟内存技术
 * 程序规模的增长远大于存储器容量的增长速度 ，让更多的程序运行在有限的内存内  
 <div align="center"><img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/memorizer.PNG" width=50% /></div>   
 
 * **覆盖技术**  
   * **目标**：在较小的可用内存中运行较大的程序，常用于多道程序系统，与区分存储管理配合使用
   * **原理**：把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行
   * **缺点**：(1)程序员要划分功能区，增加了编程的复杂度  
   &emsp;&emsp;&emsp;(2)覆盖模块从外出装入内存，实际上是以时间换空间
 * **交换技术**  
   * **目标**：多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源  
   * **方法**：可将暂时不能运行的程序送到外存，从而获得空闲内存空间
   * **缺点**：增加了处理器的开销
 * **覆盖与交换的比较**  
   * 覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间逻辑覆盖结构。
   * 交换技术是以在内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，交换发送在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部
 * **虚存技术**（Physical Memory + Disk = Virtual Memory） 
   * **目标**：(1)像覆盖技术那样，不是把程序的所有内容都放在内存中，但要做得更好，由操作系统自动来完成，无需程序员的干涉  
   &emsp;&emsp;&emsp;(2)像交换技术那样，能够实现进程在内存与外存之间的交换，但要做的更好，只对进程的部分内容在内存和外存之间进行交换
   * **程序的局部性原理**：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域，表现为时间局部性和空间局部性
   * **基本概念**  
     * 在装入程序时，不必将其全部装入到内存，而只需要将当前需要执行的部分页面或段装入到内存，就可以让程序开始执行
     * 在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或却段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序
     * 另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空间存放将要装入的程序以及将要调入的页面或段
## 六.虚拟内存技术（二）
* **最优页面置换算法**  
  * **功能**：当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换
  * **目标**：尽可能地减少页面的换进换出次数（即缺页中断的次数）。具体来说，把未来不会再使用的或短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计数来进行预测；
  * **基本思路**：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需要等待多长时间，丛总选择等待时间最长的那个，作为被置换的页面。但这只是一种理想情况，在实际系统中是无法实现的，因为操作系统无从知道每一个页面要等待多长时间以后才会再次被访问。可用作其他算法的性能评价的依据（在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法）。
  * **页面锁定（frame locking）**：用于描述必须常驻内存的操作系统的关键部分或时间键（time-critical）的应用进程。实现的方法是：在页表中添加锁定标志位（lock bit）
* **先进先出算法（FIFO）**
  * **基本思路**：选择在内存中驻留时间最长的页面并淘汰之。具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面。从链表的排列顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。当发生一个缺页中断时，吧链首页面淘汰出局，并把新的页面添加到链表的末尾。
  * **缺点**：性能较差，调出的页面有可能是经常要访问的页面，并且有Belady现象。FIFO算法很少单独使用。
  * **Belady现象**：在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的异常现象。
  * **Belady现象的原因**：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（即替换较少使用的页面），因为，被它置换出去的页面并不一定是进程不会访问的。
* **最近最近未使用算法（Least Recently Used LRU）**
  * **基本思路**：当一个缺页中断发生时，选择最久未使用的那个页面，并淘汰之。它是对最优页面置换算法的一个近似，其依据是程序的局部性原理，即在最近一小段时间（最近几条指令）内，如果某些页面被频繁地访问，纳秒在将来的一小段时间内，它们还可能会再一次被频繁地访问。反过来说，如果在过去某些页面长时间未被访问，那么在将来它们还可能会长时间地得不到访问。
  * **缺点**：LRU算法需要记录各个页面使用时间的先后顺序，开销比较大
  * **实现方法**  
    * 系统维护一个页面链表，最近刚刚使用过的页面作为首结点，最久未使用的页面作为尾结点。每一次党文内存时，找到相应的页面，把它从链表中摘下来，在移动到链表之首。每次缺页中断发生时，淘汰链表末尾的页面。
    * 设置一个活动页面栈（不是通常意义上的栈，通常意义的栈只能在栈顶操作，不能直接操作栈的中间部分和栈底），当访问某页时，将此页号压入栈顶，然后，考察栈内是否有与此页面相同的页号，若有则抽出。当需要淘汰一个页面时，总是选择栈底的页面，它就是最久未使用的。
* **时钟页面置换算法**
  * Clock页面置换算法，LRU的近似，对FIFO的一种改进。
  * **基本思路**
    * 需要用到页表项当中的访问位，当一个页面被装入到内存时，把该位初始化为0,。然后如果这个页面被访问（读/写），则把该位置为1；
    * 把各个页面组织成环形链表（类似钟表明），把指针指向最老的页面（最先进来）；
    * 当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰；若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格
* **二次机会法**
  * Clock页面置换算法，LRU的近似，对FIFO的一种改进。
  * **基本思路**
    * 这里有一个巨大的代价来替换“脏”页（dirty page，也就是对该页做了写操作）。
    * 修改Clock算法，使它允许脏页总是在一次时钟头扫描中保留下来
    * 同时使用脏位和使用位来指导置换，被执行写操作次数越多的页，越不容易被替换出去
* **最不常用算法（Least Frequently Used,LFU）**  
  * **基本思路**：当一个缺页中断发生时，选择访问次数最少的那个页面，并淘汰之
  * **实现方法**：对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加 1.在发生缺页中断时，淘汰计数值最小的那个页面
  * **LRU和LFU的区别**：LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数或频度，访问次数越多越好。
* **局部页替换算法的问题** 
  * 前面介绍的各种页面置换算法，都是基于一个前提，即**程序的局部性原理**，如果局部性原理不成立，那么各种页面置换算法就没有什么分别，局部性原理存在的证明、定量分析要依靠工作集模型。
* **工作集模型**  

&emsp;&emsp;&emsp;<img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/%E5%B7%A5%E4%BD%9C%E9%9B%86.PNG" width = 40.2% />&emsp;&emsp;<img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/%E5%B7%A5%E4%BD%9C%E9%9B%86%E4%BE%8B%E5%AD%90.PNG" width = 41% />  
&emsp;&emsp;&emsp;<img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/%E5%B8%B8%E9%A9%BB%E9%9B%86.PNG" width = 40.2% />&emsp;&emsp;<img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/%E5%B7%A5%E4%BD%9C%E9%9B%86%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96.PNG" width = 41% />  
* **两个全局置换算法**  
  * **工作集页面置换算法**：追踪之前τ个的引用，在之前τ个内存访问的页引用是工作集，τ被称为窗口大小。
  * **缺页率页面置换算法**
    * **可变分配策略**：常驻集大小可变。例如：每个进程在刚刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后在进程运行过程中，再动态地调整常驻集的大小。
    * 可采用全局页面置换的方式，当发生一个缺页中断时，被置换的页面可以是在其它进程当中，各个并发进程竞争地使用物理页面。
    * **优缺点**：性能较好，但增加了系统开销。
    * **具体实现**：可以使用缺页率算法（PFF，page fault frequency）来动态调整常驻集的大小。
    * **缺页率**：缺页次数/内存访问次数。
    * **影响缺页率的因素**
      * 页面置换算法
      * 分配给进程的物理页数目
      * 页面本身的大小
      * 程序的编写方法
    * **一个交替的工作集计算明确的试图最小化页缺失**
      * 当缺页率高的时候--增加工作集
      * 当缺页率低的时候--减少工作集
      * **算法**：保持追踪缺失发生概率
        * 当发生缺失时，从上次页缺失起计算这个时间记录这个时间，t_last是上次的页缺失的时间。
        * 如果发生页缺失之间的时间是“大”的，之后减少工作集，如果t_current-t_last>T,之后从内存中移除所有在[t_last，t_current]时间内没有被引用的页。
        * 如果发生页缺失之间的时间是“小”的，之后增加工作集，如果t_current-t_last<=T,之后增加缺失页到工作集中。
        <div align="center"><img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/%E4%BA%A4%E6%9B%BF%E5%B7%A5%E4%BD%9C%E9%9B%86%E8%AE%A1%E7%AE%97.PNG" width=50% /></div> 

## 七.进程
* **进程定义**：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。
* **进程组成**：包含了正在运行的一个程序的所有状态信息。
  * 程序的代码
  * 程序处理的数据
  * 程序计数器中的值，指示下一条将要运行的指令；
  * 一组通用的寄存器的当前值，堆、栈；
  * 一组系统资源（如打开的文件）；
* **进程与程序的关系**
  * 程序时产生进程的基础
  * 程序的每次运行构成不同的进程
  * 进程是程序功能的体现
  * 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序
* **进程与程序的区别**
  * 进程是动态的，程序是静态的;程序是由序代码的集合；进程是程序的执行，进行有核心态/用户态
  * 进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存
  * 进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）
* **进程的类比**
<div align="center"><img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/%E8%BF%9B%E7%A8%8B%E7%B1%BB%E6%AF%94.PNG" width=50% /></div>  

* **进程的特点**
  * 动态性：可动态地创建、结束进程；
  * 并发性：进程可以被独立调度并占用处理机运行；**并发并行**
  * 独立性：不同进程的工作不相互影响；**分页机制可以保证，不同的进程分配不同的页表**
  * 制约性：因访问共享数据/资源或进程同步而产生制约。
  * 描述进程的数据结构：进程控制块（Process Control Block,PCB）,操作系统为每个进程都维护了一个PCB，用来保持与该进程有关的各种状态信息
* **进程控制块**：操作系统管理控制进程运行所用的信息集合。操作系统用PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标志。 
  * **进程的创建**：为该进程生成一个PCB；
  * **进程的终止**：回收它的PCB；
  * **进程的组织管理**：通过对PCB的组织管理来实现；
* **PCB三大类信息**
  * **进程标识信息**：如本进程的标识，本进程的产生者标识（父进程标识）；用户标识。
  * **处理机状态信息保存区**：保存进程的运行现场信息；
    * **用户可见寄存器**：用户程序可以使用的数据，地址等寄存器。
    * **控制和状态寄存器**：如程序计数器（PC），程序状态字(PSW)。
    * **栈指针**：过程调用/系统调用/中断处理和返回时需要用到它。
  * **进程控制信息**
    * **调度和状态信息**：用于操作系统调度进程并占用处理机使用。
    * **进程间通信信息**：为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中。
    * **存储管理信息**：包含有指向本进程映像存储空间的数据结构。
    * **进程所用资源**：说明由进程打开、使用的系统资源，如打开的文件等。
    * **有关数据结构连接信息**：进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。
* **PCB三大类信息**
  * **PCB的组织方式**
    * **链表**：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表。各状态的进程形成不同的链表：就绪链表，阻塞链表。
    * **索引表**：同一状态的进程归入一个index表（由index指向PCB），多个状态对应多个不同的index表。各状态的进程形成不同的索引表：就绪索引表，阻塞索引表。
* **进程的声明周期原理**
  * **进程创建**：引起进程创建的3个主要事件
    * **系统初始化时**
    * **用户请求创建一个新进程**
    * **正在运行的进程执行了创建进程的系统调用**
  * **进程运行**
    * 内核选择一个就绪的进程，让它占用处理机并执行。
  * **进程等待**：在以下情况下，进程等待（阻塞）
    * 请求并等待系统服务，无法马上完成
    * 启动某种操作，无法马上完成
    * 需要的数据没有到达
    * **进程只能自己阻塞自己，因为只有进程自身才能知道何时需要等待某种事件的发生**
  * **进程唤醒**：唤醒进程的原因
    * 被阻塞进程需要的资源可被满足
    * 被阻塞进程等待的事件到达
    * 将该进程的PCB插入到就绪队列
    * **进程只能被别的进程或操作系统唤醒**
  * **进程结束**：在以下四种情形下，进程结束
    * 正常退出（自愿的）
    * 错误退出（自愿的）
    * 志明错误（强制性的）
    * 被其他进程所杀（强制性的）
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
