# 操作系统
## 一.内核（OS Kernel）特征
 * 并发（不同于并行，并行必须为多核）：计算机系统中同时存在多个运行的程序，需要OS管理和调度
 * 共享：“同时”访问，互斥共享
 * 虚拟：利用多道程序设计技术，让每个用户（应用程序）都觉得有一个计算机专门为他服务
 * 异步：程序的执行不是一贯到底，而是走走停停，向前推进的素的不可预知，但只要运行环境相同，OS需要保证程序<br/>　　　运行的结果也要相同</br>
## 二.操作系统的启动
 * DISK：存放OS，bootloader也在DISK存储着
 * BIOS：基本I/O处理系统，开机检测各种各样的 I/O外设，BIOS系统程序本身就在内存里放着，不在DISK内
 * 所谓CPU控制权的交接，可以理解为CPU执行哪段代码，刚刚启动时，CPU执行BIOS程序代码，BIOS程序代码也可以控制CUP跳到内存的其它地址空间执行相应的程序，当    BIOS程序执行完毕开始执行加载进来的bootloader代码时，可以说BIOS将CPU的控制权交给了bootloader
 * 操作系统与设备和程序交互（操作系统 interface）：系统调用、异常、中断，面向外设是通过中断和IO来处理的，面向应用程序是通过系统调用和异常来处理
 * 用户态、内核态
## 三.计算机体系结构及内存分层
 * 虚拟内存：内存指的是电脑的RAM，虚拟内存是将磁盘硬盘的内存虚拟化为内存，具体是将RAM里面暂时不用的数据程序存储到硬盘里，从而省出了内存的部分空间，可以看成虚拟化硬盘的一部分存储空间为内存
 * 地址空间：物理地址和逻辑地址
 * 连续内存分配：内存碎片问题、分区的动态分配包括第一适配、最佳适配、最差适配，压缩式碎片整理、交换式碎片整理
## 四.非连续内存分配
 * 分段：段的大小不同
 * 分页：每页的大小相同
 * 页表：页表就是一个大的数组
 * TLB：缓存近期访问的页帧转换表项，加快访问速度
 * 多级页表：以时间换空间，分级次数越多，访问的次数也就越多，那些对应关系不在内存里的页表（flag里resident标志位为0的页表，也就是不合法页表）就占用内存的空间了
 * 反向页表：以帧号为index，以页号为存储内容，这样的话页表的大小只与物理地址空间大小有关，而与逻辑地址空间大小无关，页表是小了，但查找费时间
 * 相应的方案有：基于页寄存器的方案，但无法索引，因为我们要的是根据页号获得帧号<br/>　  基于关联内存（类似HashMap）的方案，key放置页号，value放置帧号，缺点是造价高，太大时也无法放进CPUkey</br>　基于哈希（hash）查找的方案
 ## 五.虚拟内存技术
 * 程序规模的增长远大于存储器容量的增长速度 ，让更多的程序运行在有限的内存内
 <br>　　　<img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/memorizer.PNG" width = 40% height = 35% /><br/>
 
 * 覆盖技术
 * 交换技术
 * 虚存技术
