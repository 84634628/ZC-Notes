# 操作系统
## 一.内核（OS Kernel）特征
 * 并发（不同于并行，并行必须为多核）：计算机系统中同时存在多个运行的程序，需要OS管理和调度
 * 共享：“同时”访问，互斥共享
 * 虚拟：利用多道程序设计技术，让每个用户（应用程序）都觉得有一个计算机专门为他服务
 * 异步：程序的执行不是一贯到底，而是走走停停，向前推进的素的不可预知，但只要运行环境相同，OS需要保证程序<br/>　　　运行的结果也要相同</br>
## 二.操作系统的启动
 * DISK：存放OS，bootloader也在DISK存储着
 * BIOS：基本I/O处理系统，开机检测各种各样的 I/O外设，BIOS系统程序本身就在内存里放着，不在DISK内
 * 所谓CPU控制权的交接，可以理解为CPU执行哪段代码，刚刚启动时，CPU执行BIOS程序代码，BIOS程序代码也可以控制CUP跳到内存的其它地址空间执行相应的程序，当    BIOS程序执行完毕开始执行加载进来的bootloader代码时，可以说BIOS将CPU的控制权交给了bootloader
 * 操作系统与设备和程序交互（操作系统 interface）：系统调用、异常、中断，面向外设是通过中断和IO来处理的，面向应用程序是通过系统调用和异常来处理
 * 用户态、内核态
## 三.计算机体系结构及内存分层
 * 虚拟内存：内存指的是电脑的RAM，虚拟内存是将磁盘硬盘的内存虚拟化为内存，具体是将RAM里面暂时不用的数据程序存储到硬盘里，从而省出了内存的部分空间，可以看成虚拟化硬盘的一部分存储空间为内存
 * 地址空间：物理地址和逻辑地址，逻辑地址是连续的，CPU依据逻辑地址去寻找相应的物理地址
 * 连续内存分配：内存碎片问题、分区的动态分配包括第一适配、最佳适配、最差适配，压缩式碎片整理、交换式碎片整理
## 四.非连续内存分配
 * 分段：段号+段内偏移量，段的大小不同，好处是可以实现隔离和共享  
 * 分页：页号+偏移量，每页的大小相同。逻辑地址的页对应物理地址的帧，一般来说页的数目大于帧的数目，因为共享机制的存在
 * 页表：页表就是一个大的数组
 * TLB：缓存近期访问的页帧转换表项，加快访问速度
 * 多级页表：以时间换空间，分级次数越多，访问的次数也就越多，那些对应关系不在内存里的页表（flag里resident标志位为0的页表，也就是不合法页表）就占用内存的空间了
 * 反向页表：以帧号为index，以页号为存储内容，这样的话页表的大小只与物理地址空间大小有关，而与逻辑地址空间大小无关，页表是小了，但查找费时间
 * 相应的方案有：(1)基于页寄存器的方案，但无法索引，因为我们要的是根据页号获得帧号。(2)基于关联内存（类似HashMap）的方案，key放置页号，value放置帧号，缺点是造价高，太大时也无法放进CPU内存。(3)基于哈希（hash）查找的方案。
 ## 五.虚拟内存技术
 * 程序规模的增长远大于存储器容量的增长速度 ，让更多的程序运行在有限的内存内
 
 　　　　　　<img src="https://github.com/84634628/ZC-Notes/blob/master/docs/pictures/memorizer.PNG" width = 40% height = 35% />  
 * 覆盖技术  
   * 目标：在较小的可用内存中运行较大的程序，常用于多道程序系统，与区分存储管理配合使用
   * 原理：把程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行
   * 缺点：(1)程序员要划分功能区，增加了编程的复杂度  
 　　　(2)覆盖模块从外出装入内存，实际上是以时间换空间  
 * 交换技术
 * 虚存技术
